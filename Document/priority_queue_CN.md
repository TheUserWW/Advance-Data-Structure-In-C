# **优先队列（最小堆）实现文档**

---

## **1. 简介**
本文档描述了一个基于**最小堆**的**优先队列**实现。该优先队列支持高效地插入 (`push`)、删除 (`pop`)，以及获取最小值 (`front`) 和最大值 (`back`)。

---

## **2. 数据结构**
优先队列使用**二叉最小堆**实现，其中：
- 最小的元素始终位于根节点 (`heap[1]`)
- 每个父节点的值 ≤ 其子节点的值
- 堆存储在一个数组中，索引从 `1` 开始，便于父子节点计算

---

## **3. 函数说明**

### **3.1 `pq_create()` - 创建优先队列**
**功能**：  
分配内存创建一个新的空优先队列，初始容量为`0`。  
**时间复杂度**：\(O(1)\)  
**空间复杂度**：\(O(1)\)  

**示例**：
```c
PriorityQueue *pq = pq_create();  // 创建一个空的优先队列
```

---

### **3.2 `pq_free(PriorityQueue *pq)` - 释放内存**
**功能**：  
释放堆数组和优先队列结构体占用的内存。  
**时间复杂度**：\(O(1)\)  
**空间复杂度**：\(O(1)\)  

**示例**：
```c
pq_free(pq);  // 释放优先队列使用的所有内存
```

---

### **3.3 `pq_swap(int *a, int *b)` - 交换两个元素**
**功能**：  
辅助函数，用于交换两个整数值。  
**时间复杂度**：\(O(1)\)  
**空间复杂度**：\(O(1)\)  

**示例**：
```c
int x = 5, y = 10;
pq_swap(&x, &y);  // 交换后 x=10, y=5
```

---

### **3.4 `pq_swim(PriorityQueue *pq, int k)` - 上浮操作**
**功能**：  
将元素向上移动以维持最小堆性质。  
**时间复杂度**：\(O(\log n)\)（最坏情况下从叶子节点移动到根节点）  
**空间复杂度**：\(O(1)\)  

**示例**：
```c
pq_push(pq, 3);  // 如果3比其父节点小，会上浮
```

---

### **3.5 `pq_sink(PriorityQueue *pq, int k)` - 下沉操作**
**功能**：  
将元素向下移动以维持最小堆性质。  
**时间复杂度**：\(O(\log n)\)（最坏情况下从根节点移动到叶子节点）  
**空间复杂度**：\(O(1)\)  

**示例**：
```c
pq_pop(pq);  // 将根节点与最后一个元素交换后，新的根节点会下沉
```

---

### **3.6 `pq_empty(PriorityQueue *pq)` - 检查是否为空**
**功能**：  
判断优先队列是否为空。  
**时间复杂度**：\(O(1)\)  
**空间复杂度**：\(O(1)\)  

**示例**：
```c
if (pq_empty(pq)) printf("队列为空！\n");
```

---

### **3.7 `pq_push(PriorityQueue *pq, int value)` - 插入元素**
**功能**：  
向优先队列中插入新元素并调整堆结构。
- 如果堆已满，容量**翻倍**（使用`realloc`）
- 然后执行**上浮**操作维持堆性质

**时间复杂度**：
- 平均：\(O(\log n)\)（上浮操作）
- 最坏（扩容时）：\(O(n)\)

**空间复杂度**：
- 分摊 \(O(1)\)（采用倍增策略）

**示例**：
```c
pq_push(pq, 10);  // 向堆中插入10
pq_push(pq, 5);   // 插入5，可能会上浮
```

---

### **3.8 `pq_front(PriorityQueue *pq)` - 获取最小值**
**功能**：  
返回最小元素（最小堆的根节点）。  
**时间复杂度**：\(O(1)\)  
**空间复杂度**：\(O(1)\)  

**示例**：
```c
int min_val = pq_front(pq);  // 获取最小元素
```

---

### **3.9 `pq_back(PriorityQueue *pq)` - 获取最大值**
**功能**：  
查找最大元素（必定在叶子节点中）。  
**时间复杂度**：\(O(n)\)（需要扫描所有叶子节点）  
**空间复杂度**：\(O(1)\)  

**示例**：
```c
int max_val = pq_back(pq);  // 获取堆中最大元素
```

---

### **3.10 `pq_pop(PriorityQueue *pq)` - 删除最小值**
**功能**：  
移除并返回最小元素。
- 将根节点与最后一个元素交换
- 执行**下沉**操作恢复堆性质
- 如果堆过于稀疏，容量**减半**（使用`realloc`）

**时间复杂度**：
- 平均：\(O(\log n)\)（下沉操作）
- 最坏（缩容时）：\(O(n)\)

**空间复杂度**：
- 分摊 \(O(1)\)（采用减半策略）

**示例**：
```c
int min_val = pq_pop(pq);  // 移除并返回最小元素
```

---

### **3.11 `pq_size(PriorityQueue *pq)` - 获取元素数量**
**功能**：  
返回优先队列中的元素个数。  
**时间复杂度**：\(O(1)\)  
**空间复杂度**：\(O(1)\)  

**示例**：
```c
int size = pq_size(pq);  // 获取当前元素数量
```

---

## **4. 时间复杂度总结**
| 操作 | 平均情况 | 最坏情况 |
|------|---------|---------|
| `pq_create()` | \(O(1)\) | \(O(1)\) |
| `pq_free()` | \(O(1)\) | \(O(1)\) |
| `pq_push()` | \(O(\log n)\) | \(O(n)\)（扩容时） |
| `pq_pop()` | \(O(\log n)\) | \(O(n)\)（缩容时） |
| `pq_front()` | \(O(1)\) | \(O(1)\) |
| `pq_back()` | \(O(n)\) | \(O(n)\) |
| `pq_empty()` | \(O(1)\) | \(O(1)\) |
| `pq_size()` | \(O(1)\) | \(O(1)\) |

---

## **5. 总结**
本实现提供了一个高效的**基于最小堆的优先队列**，具有：
- 快速的插入和删除操作（平均 `O(log n)`）
- 自动扩容机制（每次插入分摊 `O(1)` 空间）
- 便捷的最小值访问（`O(1)`）和最大值查找（`O(n)`）
